#include <iostream>
using namespace std;

// 不带参数的宏定义：用 PI 来代替 3.1415926 这个字符串。
// 程序源码中我们写的是 PI。在编译预处理时，所有在该#define之后写的PI，都会被替换成 3.1415926
#define PI      3.1415926
#define DPI     2 * PI
#define DPICPI  PI * DPI
//---------------------------------

#define S(a,b) a*b
#define K(a,b) a*2
// 这里的r最好加上括号，否则代码中的 AREA(1+5); 会被替换成 ==> 3.1415926 * 1+5 * 1+5 
// r加括号后 AREA(1+5);  ==> 3.1415926 * (1+5) * (1+5)
#define AREA(r) PI  * (r) * (r) 
//---------------------------------

//宏替换复杂语句
// 取最大值
#define MAX(x,y) (x)>(y)?(x):(y)  //三目运算
//---------------------------------

//宏替换多行语句（加 '\' 来换行，让#define认为这多行代码是一行）
#define MACROTEST do {\
printf("test\n");\
} while(0);


//---------------------------------
//函数声明
void func1();

int main023()
{
    //c语言入门教程-视频-23
    cout << "023_编译预处理_宏定义" << endl;
    cout << "-------------------------------------------------------" << endl;

    /*
        预备知识
            - 一个项目可以通过编译、链接最终形成一个可执行文件。
            - 每个源文件(.cpp），都会单独编译，编译成一个目标文件（.o，也可能是.obj，扩展名跟操作系统有关）。
            - 系统把这些 .o 文件进行连接，最终形成一个可执行文件。
            - 编译干了什么事情？
                - 笼统的说：词法、语法分析，目标文件（临时文件）的生成，优化之类的事情。
                - 编译拆开来讲，一般会做如下事情：
                    1. 预处理（预编译）：
                        - 在源程序.cpp中加入一些特殊的代码（特殊的命令），这些特殊代码有一些特殊的能力，提供一些特殊功能。
                        - 编译系统会先对这些代码做处理，这就叫“预处理”。处理结果再和源程序代码一起进行编译、汇编，这一系列操作。
                    2. 编译：词法、语法分析，目标文件的生成，优化。
                    3. 汇编：产生 .o/.obj 目标文件。

            - C语言一般提供3种预处理功能：
                1. 宏定义
                2. 文件包含
                3. 条件编译
                - 这3种功能也是通过在程序中写代码来实现，只不过这些代码比较特殊，都是以'#'开头。
    */


    /*
        一、不带参数的宏定义
            - 用一个指定的标识符代表一个字符串
            - 一般形式：    #define 标识符(宏名) 字符串

            - 好处：
                1. 用一个简单的标识符代替一个长字符串，这个标识符也被称为宏名，在预编译时将宏名替换成字符串的过程叫 "宏展开"。#define 就是宏定义命令。
                2. 增加了修改的便利性，为修改提供了极大的便利性，这种便利被很频繁的使用。也叫提高了程序的可移植性。
    
            - 说明：
                1. 宏名：一般都有用大写字母。
                2. 宏定义：他不是C语句（C语句是';'号结尾的），所以不必在行末加';'，如果加分号则连分号会被一起替换。
                3. #define 命令出现在程序中函数的外面（一般在.cpp文件最上面），宏名 的有效范围是#define之后，到本文件结束，不能跨文件使用。
                4. 可以用 #undef 命令终止宏定义的作用域（很少使用）。
                5. 用 #define 进行宏定义时，还可以引用已定义的宏。
                6. 字符串内的字符，即使与宏名相同，也不进行替换（一定要注意！！！）。
    */
    cout << "一、不带参数的宏定义" << endl;
    //printf("%f\n", PI);  // 等价于 ==> printf("%f\n", 3.1415926); 
    
    float ftmp;
    ftmp = PI * 2;  // ftmp = 3.1415926 * 2; 这种替换不做语法检查，替换完之后直接参与乘法运算。
    printf("%f\n", ftmp);

    func1();

    float ftmp2;
    ftmp2 = PI * 2;  // 3.1415926 * 2
    ftmp2 = DPI; // 2 * 3.1415926
    ftmp2 = DPICPI;  // 3.1415926 * 2 * 3.1415926

    //6.
    char stmp[100] = "DPICPI";  // 字符串内的字符，即使与宏名相同，也不进行替换
    cout << "-------------------------------------------------------" << endl;

    /*
        二、带参数的宏定义
            - 一般形式
                #define 宏名(参数表) 字符串
            - 也是用 右边 “字符串” 代替 “宏名(参数表)”。
            - 一般 右边“字符串”中都会包含参数表中所指定的参数（如果不包含也可以，但是没啥意义）。
                - 如果 字符串中有 宏名后列出的参数比如(a,b)，则将 字符串中 相应的 形参 替代 为程序代码中的传递的实参。
                - 如果 字符串中的 字符不是参数表中的字符（比如 称号'*'），则保留该字符。
            -  宏定义时，宏名和带参数的括号之间不能加空格，否则，空格以后的字符都作为替代字符串的一部分了。
    */
    cout << "二、带参数的宏定义" << endl;

    int tmp3 = S(2, 3);  //把2，3分别代替宏定义中的形参a，b。 ==> 2 * 3
    int tmp4 = K(3, 4);  // ==> 3 * 2

    float area;
    area = AREA(3.6); // ==> 3.1415926 * 3.6 * 3.6

    //说明
    area = AREA(1+5);
    cout << "-------------------------------------------------------" << endl;

    /*
        三、宏定义和函数的区别
            1. 函数调用时，先求出实参表达式的值，然后带入形参。带参数的宏只进行简单的字符替换，并没有求实参表达式的值的行为。
            2. 函数调用是在程序运行时处理，分配临时内存。宏展开是在编译时进行的，展开时不分配内存，也没有返回值，也没有值传递。
            3. 宏的参数没有类型的概念，只是个符号，展开时带入指定的字符串中。
            4. 使用宏次数多时，宏展开后源程序变长。函数调用不会使源程序变长。
            5. 宏展开只占用编译时间，不占用运行时间。函数调用占用运行时间（如分配内存、传递参数、执行函数体、返回值等）。
    */
    cout << "三、宏定义和函数的区别" << endl;
    //宏替换复杂语句
    int result = MAX(3, 4);  // ==> (3)>(4)?(3):(4)

    //宏替换多行语句
    MACROTEST;
    cout << "-------------------------------------------------------" << endl;

    return 0;
}

//#undef PI // 结束了PI的作用域

void func1()
{
    float ftmp;
    ftmp = PI * 2;
    printf("func1()函数内部：ftmp = %f\n", ftmp);
}